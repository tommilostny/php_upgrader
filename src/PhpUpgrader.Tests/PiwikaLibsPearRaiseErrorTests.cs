namespace PhpUpgrader.Tests;

public class PiwikaLibsPearRaiseErrorTests : UnitTestWithOutputBase
{
    public PiwikaLibsPearRaiseErrorTests(ITestOutputHelper output) : base(output)
    {
    }

    [Fact]
    public void UpgradesValidFile()
    {
        //Arrange
        var file = new FileWrapper(Path.Join("piwika", "libs", "PEAR.php"), "<?php\r\n/**\r\n * PEAR, the PHP Extension and Application Repository\r\n *\r\n * PEAR class and PEAR_Error class\r\n *\r\n * PHP versions 4 and 5\r\n *\r\n * @category   pear\r\n * @package    PEAR\r\n * @author     Sterling Hughes <sterling@php.net>\r\n * @author     Stig Bakken <ssb@php.net>\r\n * @author     Tomas V.V.Cox <cox@idecnet.com>\r\n * @author     Greg Beaver <cellog@php.net>\r\n * @copyright  1997-2010 The Authors\r\n * @license    http://opensource.org/licenses/bsd-license.php New BSD License\r\n * @version    CVS: $Id$\r\n * @link       http://pear.php.net/package/PEAR\r\n * @since      File available since Release 0.1\r\n */\r\n\r\n/**#@+\r\n * ERROR constants\r\n */\r\ndefine('PEAR_ERROR_RETURN',     1);\r\ndefine('PEAR_ERROR_PRINT',      2);\r\ndefine('PEAR_ERROR_TRIGGER',    4);\r\ndefine('PEAR_ERROR_DIE',        8);\r\ndefine('PEAR_ERROR_CALLBACK',  16);\r\n/**\r\n * WARNING: obsolete\r\n * @deprecated\r\n */\r\ndefine('PEAR_ERROR_EXCEPTION', 32);\r\n/**#@-*/\r\ndefine('PEAR_ZE2', (function_exists('version_compare') &&\r\n                    version_compare(zend_version(), \"2-dev\", \"ge\")));\r\n\r\nif (substr(PHP_OS, 0, 3) == 'WIN') {\r\n    define('OS_WINDOWS', true);\r\n    define('OS_UNIX',    false);\r\n    define('PEAR_OS',    'Windows');\r\n} else {\r\n    define('OS_WINDOWS', false);\r\n    define('OS_UNIX',    true);\r\n    define('PEAR_OS',    'Unix'); // blatant assumption\r\n}\r\n\r\n$GLOBALS['_PEAR_default_error_mode']     = PEAR_ERROR_RETURN;\r\n$GLOBALS['_PEAR_default_error_options']  = E_USER_NOTICE;\r\n$GLOBALS['_PEAR_destructor_object_list'] = array();\r\n$GLOBALS['_PEAR_shutdown_funcs']         = array();\r\n$GLOBALS['_PEAR_error_handler_stack']    = array();\r\n\r\n@ini_set('track_errors', true);\r\n\r\n/**\r\n * Base class for other PEAR classes.  Provides rudimentary\r\n * emulation of destructors.\r\n *\r\n * If you want a destructor in your class, inherit PEAR and make a\r\n * destructor method called _yourclassname (same name as the\r\n * constructor, but with a \"_\" prefix).  Also, in your constructor you\r\n * have to call the PEAR constructor: $this->PEAR();.\r\n * The destructor method will be called without parameters.  Note that\r\n * at in some SAPI implementations (such as Apache), any output during\r\n * the request shutdown (in which destructors are called) seems to be\r\n * discarded.  If you need to get any debug information from your\r\n * destructor, use error_log(), syslog() or something similar.\r\n *\r\n * IMPORTANT! To use the emulated destructors you need to create the\r\n * objects by reference: $obj = new PEAR_child;\r\n *\r\n * @category   pear\r\n * @package    PEAR\r\n * @author     Stig Bakken <ssb@php.net>\r\n * @author     Tomas V.V. Cox <cox@idecnet.com>\r\n * @author     Greg Beaver <cellog@php.net>\r\n * @copyright  1997-2006 The PHP Group\r\n * @license    http://opensource.org/licenses/bsd-license.php New BSD License\r\n * @version    Release: 1.9.1\r\n * @link       http://pear.php.net/package/PEAR\r\n * @see        PEAR_Error\r\n * @since      Class available since PHP 4.0.2\r\n * @link        http://pear.php.net/manual/en/core.pear.php#core.pear.pear\r\n */\r\nclass PEAR\r\n{\r\n    /**\r\n     * Whether to enable internal debug messages.\r\n     *\r\n     * @var     bool\r\n     * @access  private\r\n     */\r\n    var $_debug = false;\r\n\r\n    /**\r\n     * Constructor.  Registers this object in\r\n     * $_PEAR_destructor_object_list for destructor emulation if a\r\n     * destructor object exists.\r\n     *\r\n     * @param string $error_class  (optional) which class to use for\r\n     *        error objects, defaults to PEAR_Error.\r\n     * @access public\r\n     * @return void\r\n     */\r\n    function PEAR($error_class = null)\r\n    {\r\n        self::__construct($error_class);\r\n    }\r\n\r\n    public function __construct($error_class = null)\r\n    {\r\n        $classname = strtolower(get_class($this));\r\n        if ($this->_debug) {\r\n            print \"PEAR constructor called, class=$classname\\n\";\r\n        }\r\n\r\n        if ($error_class !== null) {\r\n            $this->_error_class = $error_class;\r\n        }\r\n\r\n        while ($classname && strcasecmp($classname, \"pear\")) {\r\n            $destructor = \"_$classname\";\r\n            if (method_exists($this, $destructor)) {\r\n                global $_PEAR_destructor_object_list;\r\n                $_PEAR_destructor_object_list[] = &$this;\r\n                if (!isset($GLOBALS['_PEAR_SHUTDOWN_REGISTERED'])) {\r\n                    register_shutdown_function(\"_PEAR_call_destructors\");\r\n                    $GLOBALS['_PEAR_SHUTDOWN_REGISTERED'] = true;\r\n                }\r\n                break;\r\n            } else {\r\n                $classname = get_parent_class($classname);\r\n            }\r\n        }\r\n    }\r\n\r\n    /**\r\n     * This method is a wrapper that returns an instance of the\r\n     * configured error class with this object's default error\r\n     * handling applied.  If the $mode and $options parameters are not\r\n     * specified, the object's defaults are used.\r\n     *\r\n     * @param mixed $message a text error message or a PEAR error object\r\n     *\r\n     * @param int $code      a numeric error code (it is up to your class\r\n     *                  to define these if you want to use codes)\r\n     *\r\n     * @param int $mode      One of PEAR_ERROR_RETURN, PEAR_ERROR_PRINT,\r\n     *                  PEAR_ERROR_TRIGGER, PEAR_ERROR_DIE,\r\n     *                  PEAR_ERROR_CALLBACK, PEAR_ERROR_EXCEPTION.\r\n     *\r\n     * @param mixed $options If $mode is PEAR_ERROR_TRIGGER, this parameter\r\n     *                  specifies the PHP-internal error level (one of\r\n     *                  E_USER_NOTICE, E_USER_WARNING or E_USER_ERROR).\r\n     *                  If $mode is PEAR_ERROR_CALLBACK, this\r\n     *                  parameter specifies the callback function or\r\n     *                  method.  In other error modes this parameter\r\n     *                  is ignored.\r\n     *\r\n     * @param string $userinfo If you need to pass along for example debug\r\n     *                  information, this parameter is meant for that.\r\n     *\r\n     * @param string $error_class The returned error object will be\r\n     *                  instantiated from this class, if specified.\r\n     *\r\n     * @param bool $skipmsg If true, raiseError will only pass error codes,\r\n     *                  the error message parameter will be dropped.\r\n     *\r\n     * @access public\r\n     * @return object   a PEAR error object\r\n     * @see PEAR::setErrorHandling\r\n     * @since PHP 4.0.5\r\n     */\r\n    static function &raiseError($message = null,\r\n                         $code = null,\r\n                         $mode = null,\r\n                         $options = null,\r\n                         $userinfo = null,\r\n                         $error_class = null,\r\n                         $skipmsg = false)\r\n    {\r\n        // The error is yet a PEAR error object\r\n        if (is_object($message)) {\r\n            $code        = $message->getCode();\r\n            $userinfo    = $message->getUserInfo();\r\n            $error_class = $message->getType();\r\n            $message->error_message_prefix = '';\r\n            $message     = $message->getMessage();\r\n        }\r\n\r\n        if (\r\n            isset($this) &&\r\n            isset($this->_expected_errors) &&\r\n            count($this->_expected_errors) > 0 &&\r\n            count($exp = end($this->_expected_errors))\r\n        ) {\r\n            if ($exp[0] == \"*\" ||\r\n                (is_int(reset($exp)) && in_array($code, $exp)) ||\r\n                (is_string(reset($exp)) && in_array($message, $exp))\r\n            ) {\r\n                $mode = PEAR_ERROR_RETURN;\r\n            }\r\n        }\r\n\r\n        // No mode given, try global ones\r\n        if ($mode === null) {\r\n            // Class error handler\r\n            if (isset($this) && isset($this->_default_error_mode)) {\r\n                $mode    = $this->_default_error_mode;\r\n                $options = $this->_default_error_options;\r\n            // Global error handler\r\n            } elseif (isset($GLOBALS['_PEAR_default_error_mode'])) {\r\n                $mode    = $GLOBALS['_PEAR_default_error_mode'];\r\n                $options = $GLOBALS['_PEAR_default_error_options'];\r\n            }\r\n        }\r\n\r\n        if ($error_class !== null) {\r\n            $ec = $error_class;\r\n        } elseif (isset($this) && isset($this->_error_class)) {\r\n            $ec = $this->_error_class;\r\n        } else {\r\n            $ec = 'PEAR_Error';\r\n        }\r\n\r\n        if (intval(PHP_VERSION) < 5) {\r\n            // little non-eval hack to fix bug #12147\r\n            include dirname(__FILE__) . '/PEAR/FixPHP5PEARWarnings.php';\r\n            return $a;\r\n        }\r\n\r\n        if ($skipmsg) {\r\n            $a = new $ec($code, $mode, $options, $userinfo);\r\n        } else {\r\n            $a = new $ec($message, $code, $mode, $options, $userinfo);\r\n        }\r\n\r\n        return $a;\r\n    }\r\n\r\n    /**\r\n     * Simpler form of raiseError with fewer options.  In most cases\r\n     * message, code and userinfo are enough.\r\n     *\r\n     * @param mixed $message a text error message or a PEAR error object\r\n     *\r\n     * @param int $code      a numeric error code (it is up to your class\r\n     *                  to define these if you want to use codes)\r\n     *\r\n     * @param string $userinfo If you need to pass along for example debug\r\n     *                  information, this parameter is meant for that.\r\n     *\r\n     * @access public\r\n     * @return object   a PEAR error object\r\n     * @see PEAR::raiseError\r\n     */\r\n    function &throwError($message = null, $code = null, $userinfo = null)\r\n    {\r\n        if (isset($this) && ($this instanceof PEAR)) {\r\n            $a = &$this->raiseError($message, $code, null, null, $userinfo);\r\n            return $a;\r\n        }\r\n\r\n        $a = &PEAR::raiseError($message, $code, null, null, $userinfo);\r\n        return $a;\r\n    }\r\n\r\n    function staticPushErrorHandling($mode, $options = null)\r\n    {\r\n        $stack       = &$GLOBALS['_PEAR_error_handler_stack'];\r\n        $def_mode    = &$GLOBALS['_PEAR_default_error_mode'];\r\n        $def_options = &$GLOBALS['_PEAR_default_error_options'];\r\n        $stack[] = array($def_mode, $def_options);\r\n        switch ($mode) {\r\n            case PEAR_ERROR_EXCEPTION:\r\n            case PEAR_ERROR_RETURN:\r\n            case PEAR_ERROR_PRINT:\r\n            case PEAR_ERROR_TRIGGER:\r\n            case PEAR_ERROR_DIE:\r\n            case null:\r\n                $def_mode = $mode;\r\n                $def_options = $options;\r\n                break;\r\n\r\n            case PEAR_ERROR_CALLBACK:\r\n                $def_mode = $mode;\r\n                // class/object method callback\r\n                if (is_callable($options)) {\r\n                    $def_options = $options;\r\n                } else {\r\n                    trigger_error(\"invalid error callback\", E_USER_WARNING);\r\n                }\r\n                break;\r\n\r\n            default:\r\n                trigger_error(\"invalid error mode\", E_USER_WARNING);\r\n                break;\r\n        }\r\n        $stack[] = array($mode, $options);\r\n        return true;\r\n    }\r\n\r\n    function staticPopErrorHandling()\r\n    {\r\n        $stack = &$GLOBALS['_PEAR_error_handler_stack'];\r\n        $setmode     = &$GLOBALS['_PEAR_default_error_mode'];\r\n        $setoptions  = &$GLOBALS['_PEAR_default_error_options'];\r\n        array_pop($stack);\r\n        list($mode, $options) = $stack[sizeof($stack) - 1];\r\n        array_pop($stack);\r\n        switch ($mode) {\r\n            case PEAR_ERROR_EXCEPTION:\r\n            case PEAR_ERROR_RETURN:\r\n            case PEAR_ERROR_PRINT:\r\n            case PEAR_ERROR_TRIGGER:\r\n            case PEAR_ERROR_DIE:\r\n            case null:\r\n                $setmode = $mode;\r\n                $setoptions = $options;\r\n                break;\r\n\r\n            case PEAR_ERROR_CALLBACK:\r\n                $setmode = $mode;\r\n                // class/object method callback\r\n                if (is_callable($options)) {\r\n                    $setoptions = $options;\r\n                } else {\r\n                    trigger_error(\"invalid error callback\", E_USER_WARNING);\r\n                }\r\n                break;\r\n\r\n            default:\r\n                trigger_error(\"invalid error mode\", E_USER_WARNING);\r\n                break;\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n     * Push a new error handler on top of the error handler options stack. With this\r\n     * you can easily override the actual error handler for some code and restore\r\n     * it later with popErrorHandling.\r\n     *\r\n     * @param mixed $mode (same as setErrorHandling)\r\n     * @param mixed $options (same as setErrorHandling)\r\n     *\r\n     * @return bool Always true\r\n     *\r\n     * @see PEAR::setErrorHandling\r\n     */\r\n    function pushErrorHandling($mode, $options = null)\r\n    {\r\n        $stack = &$GLOBALS['_PEAR_error_handler_stack'];\r\n        if (isset($this) && ($this instanceof PEAR)) {\r\n            $def_mode    = &$this->_default_error_mode;\r\n            $def_options = &$this->_default_error_options;\r\n        } else {\r\n            $def_mode    = &$GLOBALS['_PEAR_default_error_mode'];\r\n            $def_options = &$GLOBALS['_PEAR_default_error_options'];\r\n        }\r\n        $stack[] = array($def_mode, $def_options);\r\n\r\n        if (isset($this) && ($this instanceof PEAR)) {\r\n            $this->setErrorHandling($mode, $options);\r\n        } else {\r\n            PEAR::setErrorHandling($mode, $options);\r\n        }\r\n        $stack[] = array($mode, $options);\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * Pop the last error handler used\r\n    *\r\n    * @return bool Always true\r\n    *\r\n    * @see PEAR::pushErrorHandling\r\n    */\r\n    function popErrorHandling()\r\n    {\r\n        $stack = &$GLOBALS['_PEAR_error_handler_stack'];\r\n        array_pop($stack);\r\n        list($mode, $options) = $stack[sizeof($stack) - 1];\r\n        array_pop($stack);\r\n        if (isset($this) && ($this instanceof PEAR)) {\r\n            $this->setErrorHandling($mode, $options);\r\n        } else {\r\n            PEAR::setErrorHandling($mode, $options);\r\n        }\r\n        return true;\r\n    }\r\n\r\n    /**\r\n    * OS independant PHP extension load. Remember to take care\r\n    * on the correct extension name for case sensitive OSes.\r\n    *\r\n    * @param string $ext The extension name\r\n    * @return bool Success or not on the dl() call\r\n    */\r\n    function loadExtension($ext)\r\n    {\r\n        if (extension_loaded($ext)) {\r\n            return true;\r\n        }\r\n\r\n        // if either returns true dl() will produce a FATAL error, stop that\r\n        if (\r\n            function_exists('dl') === false ||\r\n            ini_get('enable_dl') != 1 ||\r\n            ini_get('safe_mode') == 1\r\n        ) {\r\n            return false;\r\n        }\r\n\r\n        if (OS_WINDOWS) {\r\n            $suffix = '.dll';\r\n        } elseif (PHP_OS == 'HP-UX') {\r\n            $suffix = '.sl';\r\n        } elseif (PHP_OS == 'AIX') {\r\n            $suffix = '.a';\r\n        } elseif (PHP_OS == 'OSX') {\r\n            $suffix = '.bundle';\r\n        } else {\r\n            $suffix = '.so';\r\n        }\r\n\r\n        return @dl('php_'.$ext.$suffix) || @dl($ext.$suffix);\r\n    }\r\n}\r\n\r\nif (PEAR_ZE2) {\r\n    include_once dirname(__FILE__) . '/PEAR5.php';\r\n}\r\n\r\nfunction _PEAR_call_destructors()\r\n{\r\n    global $_PEAR_destructor_object_list;\r\n    if (is_array($_PEAR_destructor_object_list) &&\r\n        sizeof($_PEAR_destructor_object_list))\r\n    {\r\n        reset($_PEAR_destructor_object_list);\r\n        if (PEAR_ZE2) {\r\n            $destructLifoExists = PEAR5::getStaticProperty('PEAR', 'destructlifo');\r\n        } else {\r\n            $destructLifoExists = PEAR::getStaticProperty('PEAR', 'destructlifo');\r\n        }\r\n\r\n        if ($destructLifoExists) {\r\n            $_PEAR_destructor_object_list = array_reverse($_PEAR_destructor_object_list);\r\n        }\r\n\r\n        while (list($k, $objref) = each($_PEAR_destructor_object_list)) {\r\n            $classname = get_class($objref);\r\n            while ($classname) {\r\n                $destructor = \"_$classname\";\r\n                if (method_exists($objref, $destructor)) {\r\n                    $objref->$destructor();\r\n                    break;\r\n                } else {\r\n                    $classname = get_parent_class($classname);\r\n                }\r\n            }\r\n        }\r\n        // Empty the object list to ensure that destructors are\r\n        // not called more than once.\r\n        $_PEAR_destructor_object_list = array();\r\n    }\r\n\r\n    // Now call the shutdown functions\r\n    if (\r\n        isset($GLOBALS['_PEAR_shutdown_funcs']) &&\r\n        is_array($GLOBALS['_PEAR_shutdown_funcs']) &&\r\n        !empty($GLOBALS['_PEAR_shutdown_funcs'])\r\n    ) {\r\n        foreach ($GLOBALS['_PEAR_shutdown_funcs'] as $value) {\r\n            call_user_func_array($value[0], $value[1]);\r\n        }\r\n    }\r\n}\r\n\r\n/**\r\n * Standard PEAR error class for PHP 4\r\n *\r\n * This class is supserseded by {@link PEAR_Exception} in PHP 5\r\n *\r\n * @category   pear\r\n * @package    PEAR\r\n * @author     Stig Bakken <ssb@php.net>\r\n * @author     Tomas V.V. Cox <cox@idecnet.com>\r\n * @author     Gregory Beaver <cellog@php.net>\r\n * @copyright  1997-2006 The PHP Group\r\n * @license    http://opensource.org/licenses/bsd-license.php New BSD License\r\n * @version    Release: 1.9.1\r\n * @link       http://pear.php.net/manual/en/core.pear.pear-error.php\r\n * @see        PEAR::raiseError(), PEAR::throwError()\r\n * @since      Class available since PHP 4.0.2\r\n */\r\nclass PEAR_Error\r\n{\r\n    var $error_message_prefix = '';\r\n    var $mode                 = PEAR_ERROR_RETURN;\r\n    var $level                = E_USER_NOTICE;\r\n    var $code                 = -1;\r\n    var $message              = '';\r\n    var $userinfo             = '';\r\n    var $backtrace            = null;\r\n\r\n    /**\r\n     * PEAR_Error constructor\r\n     *\r\n     * @param string $message  message\r\n     *\r\n     * @param int $code     (optional) error code\r\n     *\r\n     * @param int $mode     (optional) error mode, one of: PEAR_ERROR_RETURN,\r\n     * PEAR_ERROR_PRINT, PEAR_ERROR_DIE, PEAR_ERROR_TRIGGER,\r\n     * PEAR_ERROR_CALLBACK or PEAR_ERROR_EXCEPTION\r\n     *\r\n     * @param mixed $options   (optional) error level, _OR_ in the case of\r\n     * PEAR_ERROR_CALLBACK, the callback function or object/method\r\n     * tuple.\r\n     *\r\n     * @param string $userinfo (optional) additional user/debug info\r\n     *\r\n     * @access public\r\n     *\r\n     */\r\n    function PEAR_Error($message = 'unknown error', $code = null,\r\n                        $mode = null, $options = null, $userinfo = null)\r\n    {\r\n        if ($mode === null) {\r\n            $mode = PEAR_ERROR_RETURN;\r\n        }\r\n        $this->message   = $message;\r\n        $this->code      = $code;\r\n        $this->mode      = $mode;\r\n        $this->userinfo  = $userinfo;\r\n\r\n        if (PEAR_ZE2) {\r\n            $skiptrace = PEAR5::getStaticProperty('PEAR_Error', 'skiptrace');\r\n        } else {\r\n            $skiptrace = PEAR::getStaticProperty('PEAR_Error', 'skiptrace');\r\n        }\r\n\r\n        if (!$skiptrace) {\r\n            $this->backtrace = debug_backtrace();\r\n            if (isset($this->backtrace[0]) && isset($this->backtrace[0]['object'])) {\r\n                unset($this->backtrace[0]['object']);\r\n            }\r\n        }\r\n\r\n        if ($mode & PEAR_ERROR_CALLBACK) {\r\n            $this->level = E_USER_NOTICE;\r\n            $this->callback = $options;\r\n        } else {\r\n            if ($options === null) {\r\n                $options = E_USER_NOTICE;\r\n            }\r\n\r\n            $this->level = $options;\r\n            $this->callback = null;\r\n        }\r\n\r\n        if ($this->mode & PEAR_ERROR_PRINT) {\r\n            if (is_null($options) || is_int($options)) {\r\n                $format = \"%s\";\r\n            } else {\r\n                $format = $options;\r\n            }\r\n\r\n            printf($format, $this->getMessage());\r\n        }\r\n\r\n        if ($this->mode & PEAR_ERROR_TRIGGER) {\r\n            trigger_error($this->getMessage(), $this->level);\r\n        }\r\n\r\n        if ($this->mode & PEAR_ERROR_DIE) {\r\n            $msg = $this->getMessage();\r\n            if (is_null($options) || is_int($options)) {\r\n                $format = \"%s\";\r\n                if (substr($msg, -1) != \"\\n\") {\r\n                    $msg .= \"\\n\";\r\n                }\r\n            } else {\r\n                $format = $options;\r\n            }\r\n            die(sprintf($format, $msg));\r\n        }\r\n\r\n        if ($this->mode & PEAR_ERROR_CALLBACK && is_callable($this->callback)) {\r\n            call_user_func($this->callback, $this);\r\n        }\r\n\r\n        if ($this->mode & PEAR_ERROR_EXCEPTION) {\r\n            trigger_error(\"PEAR_ERROR_EXCEPTION is obsolete, use class PEAR_Exception for exceptions\", E_USER_WARNING);\r\n            eval('$e = new Exception($this->message, $this->code);throw($e);');\r\n        }\r\n    }\r\n\r\n    /**\r\n     * Get the error mode from an error object.\r\n     *\r\n     * @return int error mode\r\n     * @access public\r\n     */\r\n    function getMode()\r\n    {\r\n        return $this->mode;\r\n    }\r\n\r\n    /**\r\n     * Get the callback function/method from an error object.\r\n     *\r\n     * @return mixed callback function or object/method array\r\n     * @access public\r\n     */\r\n    function getCallback()\r\n    {\r\n        return $this->callback;\r\n    }\r\n\r\n    /**\r\n     * Get the error message from an error object.\r\n     *\r\n     * @return  string  full error message\r\n     * @access public\r\n     */\r\n    function getMessage()\r\n    {\r\n        return ($this->error_message_prefix . $this->message);\r\n    }\r\n\r\n    /**\r\n     * Get error code from an error object\r\n     *\r\n     * @return int error code\r\n     * @access public\r\n     */\r\n     function getCode()\r\n     {\r\n        return $this->code;\r\n     }\r\n\r\n    /**\r\n     * Get the name of this error/exception.\r\n     *\r\n     * @return string error/exception name (type)\r\n     * @access public\r\n     */\r\n    function getType()\r\n    {\r\n        return get_class($this);\r\n    }\r\n\r\n    /**\r\n     * Get additional user-supplied information.\r\n     *\r\n     * @return string user-supplied information\r\n     * @access public\r\n     */\r\n    function getUserInfo()\r\n    {\r\n        return $this->userinfo;\r\n    }\r\n\r\n    /**\r\n     * Get additional debug information supplied by the application.\r\n     *\r\n     * @return string debug information\r\n     * @access public\r\n     */\r\n    function getDebugInfo()\r\n    {\r\n        return $this->getUserInfo();\r\n    }\r\n\r\n    /**\r\n     * Get the call backtrace from where the error was generated.\r\n     * Supported with PHP 4.3.0 or newer.\r\n     *\r\n     * @param int $frame (optional) what frame to fetch\r\n     * @return array Backtrace, or NULL if not available.\r\n     * @access public\r\n     */\r\n    function getBacktrace($frame = null)\r\n    {\r\n        if (defined('PEAR_IGNORE_BACKTRACE')) {\r\n            return null;\r\n        }\r\n        if ($frame === null) {\r\n            return $this->backtrace;\r\n        }\r\n        return $this->backtrace[$frame];\r\n    }\r\n\r\n    function addUserInfo($info)\r\n    {\r\n        if (empty($this->userinfo)) {\r\n            $this->userinfo = $info;\r\n        } else {\r\n            $this->userinfo .= \" ** $info\";\r\n        }\r\n    }\r\n\r\n    function __toString()\r\n    {\r\n        return $this->getMessage();\r\n    }\r\n\r\n    /**\r\n     * Make a string representation of this object.\r\n     *\r\n     * @return string a string with an object summary\r\n     * @access public\r\n     */\r\n    function toString()\r\n    {\r\n        $modes = array();\r\n        $levels = array(E_USER_NOTICE  => 'notice',\r\n                        E_USER_WARNING => 'warning',\r\n                        E_USER_ERROR   => 'error');\r\n        if ($this->mode & PEAR_ERROR_CALLBACK) {\r\n            if (is_array($this->callback)) {\r\n                $callback = (is_object($this->callback[0]) ?\r\n                    strtolower(get_class($this->callback[0])) :\r\n                    $this->callback[0]) . '::' .\r\n                    $this->callback[1];\r\n            } else {\r\n                $callback = $this->callback;\r\n            }\r\n            return sprintf('[%s: message=\"%s\" code=%d mode=callback '.\r\n                           'callback=%s prefix=\"%s\" info=\"%s\"]',\r\n                           strtolower(get_class($this)), $this->message, $this->code,\r\n                           $callback, $this->error_message_prefix,\r\n                           $this->userinfo);\r\n        }\r\n        if ($this->mode & PEAR_ERROR_PRINT) {\r\n            $modes[] = 'print';\r\n        }\r\n        if ($this->mode & PEAR_ERROR_TRIGGER) {\r\n            $modes[] = 'trigger';\r\n        }\r\n        if ($this->mode & PEAR_ERROR_DIE) {\r\n            $modes[] = 'die';\r\n        }\r\n        if ($this->mode & PEAR_ERROR_RETURN) {\r\n            $modes[] = 'return';\r\n        }\r\n        return sprintf('[%s: message=\"%s\" code=%d mode=%s level=%s '.\r\n                       'prefix=\"%s\" info=\"%s\"]',\r\n                       strtolower(get_class($this)), $this->message, $this->code,\r\n                       implode(\"|\", $modes), $levels[$this->level],\r\n                       $this->error_message_prefix,\r\n                       $this->userinfo);\r\n    }\r\n}\r\n\r\n/*\r\n * Local Variables:\r\n * mode: php\r\n * tab-width: 4\r\n * c-basic-offset: 4\r\n * End:\r\n */");
        //Act
        file.UpgradePiwikaLibsPearRaiseError();

        //Assert
        var updated = file.Content.ToString();
        _output.WriteLine(updated);
        Assert.True(file.IsModified);
    }
}
